var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"q4b","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * File: ert_main.c\n *\n * Code generated for Simulink model 'q4b'.\n *\n * Model version                  : 1.3\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n * C/C++ source code generated on : Wed Apr 23 19:38:50 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"q4b.h\"\n#include \"rtwtypes.h\"\n#include \"MW_target_hardware_resources.h\"\n\nvolatile int IsrOverrun = 0;\nstatic boolean_T OverrunFlag = 0;\nvoid rt_OneStep(void)\n{\n  /* Check for overrun. Protect OverrunFlag against preemption */\n  if (OverrunFlag++) {\n    IsrOverrun = 1;\n    OverrunFlag--;\n    return;\n  }\n\n#ifndef _MW_ARDUINO_LOOP_\n\n  sei();\n\n#endif;\n\n  q4b_step();\n\n  /* Get model outputs here */\n#ifndef _MW_ARDUINO_LOOP_\n\n  cli();\n\n#endif;\n\n  OverrunFlag--;\n}\n\nvolatile boolean_T stopRequested;\nvolatile boolean_T runModel;\nint main(void)\n{\n  float modelBaseRate = 1.0;\n  float systemClock = 0;\n\n  /* Initialize variables */\n  stopRequested = false;\n  runModel = false;\n  init();\n  MW_Arduino_Init();\n  rtmSetErrorStatus(q4b_M, 0);\n  q4b_initialize();\n  cli();\n  configureArduinoAVRTimer();\n  runModel =\n    rtmGetErrorStatus(q4b_M) == (NULL);\n\n#ifndef _MW_ARDUINO_LOOP_\n\n  sei();\n\n#endif;\n\n  sei ();\n  while (runModel) {\n    stopRequested = !(\n                      rtmGetErrorStatus(q4b_M) == (NULL));\n    runModel = !(stopRequested);\n    MW_Arduino_Loop();\n  }\n\n  /* Terminate model */\n  q4b_terminate();\n  cli();\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"q4b.c","type":"source","group":"model","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * File: q4b.c\n *\n * Code generated for Simulink model 'q4b'.\n *\n * Model version                  : 1.3\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n * C/C++ source code generated on : Wed Apr 23 19:38:50 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"q4b.h\"\n#include \"rtwtypes.h\"\n#include \"q4b_private.h\"\n\n/* Named constants for Chart: '<Root>/Chart' */\n#define q4b_IN_cargreen_pedred         ((uint8_T)1U)\n#define q4b_IN_carred_pedgreen         ((uint8_T)2U)\n#define q4b_IN_carred_pedred           ((uint8_T)3U)\n#define q4b_IN_caryellow_pedred        ((uint8_T)4U)\n#define q4b_IN_pending_pedred          ((uint8_T)5U)\n\n/* Block signals (default storage) */\nB_q4b_T q4b_B;\n\n/* Block states (default storage) */\nDW_q4b_T q4b_DW;\n\n/* Real-time model */\nstatic RT_MODEL_q4b_T q4b_M_;\nRT_MODEL_q4b_T *const q4b_M = &q4b_M_;\n\n/* Model step function */\nvoid q4b_step(void)\n{\n  real_T tmp;\n\n  /* Chart: '<Root>/Chart' incorporates:\n   *  Step: '<Root>/Step'\n   */\n  if (q4b_DW.is_active_c3_q4b == 0U) {\n    q4b_DW.is_active_c3_q4b = 1U;\n    q4b_B.count = 0.0;\n    q4b_B.pcount = 0.0;\n    q4b_DW.is_c3_q4b = q4b_IN_carred_pedgreen;\n  } else {\n    switch (q4b_DW.is_c3_q4b) {\n     case q4b_IN_cargreen_pedred:\n      if (q4b_B.count < 60.0) {\n        q4b_B.count++;\n        q4b_DW.is_c3_q4b = q4b_IN_cargreen_pedred;\n      } else {\n        if (q4b_M->Timing.t[0] < q4b_P.Step_Time) {\n          /* Step: '<Root>/Step' */\n          tmp = q4b_P.Step_Y0;\n        } else {\n          /* Step: '<Root>/Step' */\n          tmp = q4b_P.Step_YFinal;\n        }\n\n        if ((tmp != 0.0) && (q4b_B.count >= 60.0)) {\n          q4b_B.count = 0.0;\n          q4b_DW.is_c3_q4b = q4b_IN_caryellow_pedred;\n        }\n      }\n      break;\n\n     case q4b_IN_carred_pedgreen:\n      if (q4b_B.pcount >= 55.0) {\n        q4b_B.count++;\n        q4b_DW.is_c3_q4b = q4b_IN_carred_pedred;\n      } else {\n        q4b_B.count++;\n        q4b_B.pcount++;\n        q4b_DW.is_c3_q4b = q4b_IN_carred_pedgreen;\n      }\n      break;\n\n     case q4b_IN_carred_pedred:\n      if (q4b_B.count >= 60.0) {\n        q4b_B.count++;\n        q4b_DW.is_c3_q4b = q4b_IN_cargreen_pedred;\n      } else {\n        q4b_B.count++;\n        q4b_DW.is_c3_q4b = q4b_IN_carred_pedred;\n      }\n      break;\n\n     case q4b_IN_caryellow_pedred:\n      if (q4b_B.pcount >= 5.0) {\n        q4b_B.count = 0.0;\n        q4b_B.pcount = 0.0;\n        q4b_DW.is_c3_q4b = q4b_IN_carred_pedgreen;\n      } else {\n        q4b_B.count++;\n        q4b_DW.is_c3_q4b = q4b_IN_caryellow_pedred;\n      }\n      break;\n\n     default:\n      /* case IN_pending_pedred: */\n      if (q4b_B.pcount >= 60.0) {\n        q4b_B.count = 0.0;\n        q4b_DW.is_c3_q4b = q4b_IN_caryellow_pedred;\n      } else {\n        q4b_B.count++;\n        q4b_DW.is_c3_q4b = q4b_IN_pending_pedred;\n      }\n      break;\n    }\n  }\n\n  /* End of Chart: '<Root>/Chart' */\n\n  /* Update absolute time for base rate */\n  /* The \"clockTick0\" counts the number of times the code of this task has\n   * been executed. The absolute time is the multiplication of \"clockTick0\"\n   * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n   * overflow during the application lifespan selected.\n   */\n  q4b_M->Timing.t[0] =\n    ((time_T)(++q4b_M->Timing.clockTick0)) * q4b_M->Timing.stepSize0;\n\n  {\n    /* Update absolute timer for sample time: [1.0s, 0.0s] */\n    /* The \"clockTick1\" counts the number of times the code of this task has\n     * been executed. The resolution of this integer timer is 1.0, which is the step size\n     * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n     * application lifespan selected.\n     */\n    q4b_M->Timing.clockTick1++;\n  }\n}\n\n/* Model initialize function */\nvoid q4b_initialize(void)\n{\n  /* Registration code */\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&q4b_M->solverInfo, &q4b_M->Timing.simTimeStep);\n    rtsiSetTPtr(&q4b_M->solverInfo, &rtmGetTPtr(q4b_M));\n    rtsiSetStepSizePtr(&q4b_M->solverInfo, &q4b_M->Timing.stepSize0);\n    rtsiSetErrorStatusPtr(&q4b_M->solverInfo, (&rtmGetErrorStatus(q4b_M)));\n    rtsiSetRTModelPtr(&q4b_M->solverInfo, q4b_M);\n  }\n\n  rtsiSetSimTimeStep(&q4b_M->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetIsMinorTimeStepWithModeChange(&q4b_M->solverInfo, false);\n  rtsiSetIsContModeFrozen(&q4b_M->solverInfo, false);\n  rtsiSetSolverName(&q4b_M->solverInfo,\"FixedStepDiscrete\");\n  rtmSetTPtr(q4b_M, &q4b_M->Timing.tArray[0]);\n  q4b_M->Timing.stepSize0 = 1.0;\n}\n\n/* Model terminate function */\nvoid q4b_terminate(void)\n{\n  /* (no terminate code required) */\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"q4b.h","type":"header","group":"model","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * File: q4b.h\n *\n * Code generated for Simulink model 'q4b'.\n *\n * Model version                  : 1.3\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n * C/C++ source code generated on : Wed Apr 23 19:38:50 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef q4b_h_\n#define q4b_h_\n#ifndef q4b_COMMON_INCLUDES_\n#define q4b_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#endif                                 /* q4b_COMMON_INCLUDES_ */\n\n#include \"q4b_types.h\"\n#include <stddef.h>\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n/* Block signals (default storage) */\ntypedef struct {\n  real_T count;                        /* '<Root>/Chart' */\n  real_T pcount;                       /* '<Root>/Chart' */\n} B_q4b_T;\n\n/* Block states (default storage) for system '<Root>' */\ntypedef struct {\n  uint8_T is_active_c3_q4b;            /* '<Root>/Chart' */\n  uint8_T is_c3_q4b;                   /* '<Root>/Chart' */\n} DW_q4b_T;\n\n/* Parameters (default storage) */\nstruct P_q4b_T_ {\n  real_T Step_Time;                    /* Expression: 1\n                                        * Referenced by: '<Root>/Step'\n                                        */\n  real_T Step_Y0;                      /* Expression: 0\n                                        * Referenced by: '<Root>/Step'\n                                        */\n  real_T Step_YFinal;                  /* Expression: 1\n                                        * Referenced by: '<Root>/Step'\n                                        */\n};\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_q4b_T {\n  const char_T *errorStatus;\n  RTWSolverInfo solverInfo;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    uint32_T clockTick0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    SimTimeStep simTimeStep;\n    time_T *t;\n    time_T tArray[2];\n  } Timing;\n};\n\n/* Block parameters (default storage) */\nextern P_q4b_T q4b_P;\n\n/* Block signals (default storage) */\nextern B_q4b_T q4b_B;\n\n/* Block states (default storage) */\nextern DW_q4b_T q4b_DW;\n\n/* Model entry point functions */\nextern void q4b_initialize(void);\nextern void q4b_step(void);\nextern void q4b_terminate(void);\n\n/* Real-time Model object */\nextern RT_MODEL_q4b_T *const q4b_M;\nextern volatile boolean_T stopRequested;\nextern volatile boolean_T runModel;\n\n/*-\n * These blocks were eliminated from the model due to optimizations:\n *\n * Block '<Root>/Scope' : Unused code path elimination\n */\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'q4b'\n * '<S1>'   : 'q4b/Chart'\n */\n#endif                                 /* q4b_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"q4b_private.h","type":"header","group":"model","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * File: q4b_private.h\n *\n * Code generated for Simulink model 'q4b'.\n *\n * Model version                  : 1.3\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n * C/C++ source code generated on : Wed Apr 23 19:38:50 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef q4b_private_h_\n#define q4b_private_h_\n#include \"rtwtypes.h\"\n#include \"q4b_types.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n#endif                                 /* q4b_private_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"q4b_types.h","type":"header","group":"model","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * File: q4b_types.h\n *\n * Code generated for Simulink model 'q4b'.\n *\n * Model version                  : 1.3\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n * C/C++ source code generated on : Wed Apr 23 19:38:50 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef q4b_types_h_\n#define q4b_types_h_\n\n/* Parameters (default storage) */\ntypedef struct P_q4b_T_ P_q4b_T;\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_q4b_T RT_MODEL_q4b_T;\n\n#endif                                 /* q4b_types_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"q4b_data.c","type":"source","group":"data","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * File: q4b_data.c\n *\n * Code generated for Simulink model 'q4b'.\n *\n * Model version                  : 1.3\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n * C/C++ source code generated on : Wed Apr 23 19:38:50 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"q4b.h\"\n\n/* Block parameters (default storage) */\nP_q4b_T q4b_P = {\n  /* Expression: 1\n   * Referenced by: '<Root>/Step'\n   */\n  1.0,\n\n  /* Expression: 0\n   * Referenced by: '<Root>/Step'\n   */\n  0.0,\n\n  /* Expression: 1\n   * Referenced by: '<Root>/Step'\n   */\n  1.0\n};\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'q4b'.\n *\n * Model version                  : 1.3\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n * C/C++ source code generated on : Wed Apr 23 19:38:50 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: Atmel->AVR\n *   Number of bits:     char:   8    short:   16    int:  16\n *                       long:  32\n *                       native word size:   8\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef int int16_T;\ntypedef unsigned int uint16_T;\ntypedef long int32_T;\ntypedef unsigned long uint32_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T.                        *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*===========================================================================*\n * Complex number type definitions                                           *\n *===========================================================================*/\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647L))\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * File: rtmodel.h\n *\n * Code generated for Simulink model 'q4b'.\n *\n * Model version                  : 1.3\n * Simulink Coder version         : 24.1 (R2024a) 19-Nov-2023\n * C/C++ source code generated on : Wed Apr 23 19:38:50 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Atmel->AVR\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rtmodel_h_\n#define rtmodel_h_\n#include \"q4b.h\"\n\n/* Macros generated for backwards compatibility  */\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((void*) 0)\n#endif\n#endif                                 /* rtmodel_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"MW_ArduinoHWInit.cpp","type":"source","group":"legacy","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw/../../../../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/arduinotarget/src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n*\n* Copyright 2014-2023 The MathWorks, Inc.\n*/\n\n#include \"Arduino.h\"\n#include \"io_wrappers.h\"\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n#include \"arduinoARM_M0plusScheduler.h\"\n#elif defined(ARDUINO_ARM_CORTEX_M3)\n#include \"arduinoARMScheduler.h\"\n#include \"watchdog.h\"\n#else\n#include \"arduinoAVRScheduler.h\"\n#endif\n\n#if defined(ESP_PLATFORM)\n#include \"esp_wpa2.h\" //wpa2 library for connections to Enterprise networks\n#endif\n\n#ifdef _RTT_NUMI2C_\n#include \"MW_arduinoI2C.h\"\n#endif\n\n#if defined(ARDUINO_ARDUINO_NANO33BLE)\n#include \"MW_PWM_NANO33BLE.h\"\n#endif\n\n#if (defined(MW_ARDUINO_OV2640CSPIN)) || (defined(_RTT_SPI_SSPIN_)) || (defined(_RTT_DUE_SPI_SSPIN4_)) || (defined(_RTT_DUE_SPI_SSPIN10_)) || (defined(_RTT_DUE_SPI_SSPIN52_))\n#include \"MW_SPIwriteRead.h\"\n#endif\n\n#if (defined(_RTT_RS485_INUSE_))\n#include \"ArduinoRS485.h\"\n#endif\n\n#if (defined(_RTT_MODBUS_MASTER_)) || (defined(_RTT_MODBUS_SLAVE_))\n#include \"ArduinoModbus.h\"\n#endif\n\n#ifdef NANO_MOTOR_CARRIER\n#include <Wire.h>\n#define PMIC_ADDRESS  0x6B\n#define PMIC_REG00    0x00\n#define PMIC_REG01    0x01\n#define PMIC_REG02    0x02\n#define PMIC_REG04    0x04\n#define PMIC_REG05    0x05\nvoid MW_EnableNanoCarrierBatteryCharging(void);\n#endif\n\n// Wifi init routines\n#include <inttypes.h>\n#if (defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)) || (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n#if defined(ARDUINO_WIFI_LIB_101)\n#include <WiFi101.h>\n#elif defined(ARDUINO_WIFI_LIB_NINA)\n#include <WiFiNINA.h>\n#else\n#include <WiFi.h>\n#endif\n#include <SPI.h>\n\n/*#define that helps to stringify build flags\n//Double evaluation is needed so that the double quotes can be derived out\n//of the build flag and can be assigned to a character array */\n#define RTT_StringifyBuildFlag(x) RTT_StringParamExpanded(x)\n#define RTT_StringParamExpanded(x)  #x\n\n#if (_RTT_DISABLE_Wifi_DHCP_ == 1)\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\n#endif\n\n#if (_RTT_DISABLE_Wifi_DHCP_ == 2)\nIPAddress wifiLocalIpAddress(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, _RTT_WIFI_Local_IP4);\nIPAddress wifiGatewayAddress(_RTT_WIFI_Gateway_IP1, _RTT_WIFI_Gateway_IP2, _RTT_WIFI_Gateway_IP3, _RTT_WIFI_Gateway_IP4);\nIPAddress wifiSubnetMask(_RTT_WIFI_Subnet_IP1, _RTT_WIFI_Subnet_IP2, _RTT_WIFI_Subnet_IP3, _RTT_WIFI_Subnet_IP4);\nIPAddress wifiDNSAddress(_RTT_WIFI_DNS_IP1, _RTT_WIFI_DNS_IP2, _RTT_WIFI_DNS_IP3, _RTT_WIFI_DNS_IP4);\n#endif\n\n#ifdef ESP_PLATFORM\nIPAddress wifigateway(_RTT_WIFI_Local_IP1, _RTT_WIFI_Local_IP2, _RTT_WIFI_Local_IP3, uint8_t(1));\nIPAddress subnet(uint8_t(255),uint8_t(255),uint8_t(255),uint8_t(0));\nIPAddress dns1 = (uint32_t)0x00000000;\nIPAddress dns2 = (uint32_t)0x00000000;\n#endif\n\nchar ssid[] = RTT_StringifyBuildFlag(_RTT_WIFI_SSID);\nint configureSuccess = WL_IDLE_STATUS;\nint trialcount;\n\n#ifdef _RTT_WIFI_WEP\nchar key[] = RTT_StringifyBuildFlag(_RTT_WIFI_KEY);\nint keyIndex = _RTT_WIFI_KEY_INDEX;\n#endif //_RTT_WIFI_WEP\n\n#ifdef _RTT_WIFI_WPA\nchar wpapass[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA_PASSWORD);\n#endif //_RTT_WIFI_WPA\n\n#ifdef _RTT_WIFI_WPA2_ENTERPRISE\nchar wpa2username[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_USERNAME);\nchar wpa2password[] = RTT_StringifyBuildFlag(_RTT_WIFI_WPA2_PASSWORD);\n#endif //_RTT_WIFI_WPA2_ENTERPRISE\n#endif //(defined(_RTT_THINGSPEAK_WIFI_) || (_RTT_WIFI_TCP_ !=0) || defined(_RTT_WEBSOCKET_PORT_))\n\n#include \"MW_ArduinoHWInit.h\"\n#ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n#include \"MW_graphicPrimitive.h\"\n#endif\n\n\n\nvoid MW_Modbus_Slave_Poll(void)\n{\n    #if defined(_RTT_MODBUS_SLAVE_)\n    ModbusRTUServer.poll();\n    #endif\n}\n\nvoid MW_ArduinoNano33BLESenseInit(void)\n{\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    initVariant();\n    #if defined(SERIAL_CDC)\n    PluggableUSBD().begin();\n    SerialUSB.begin(115200);\n    #endif\n    #if defined(_RTT_PWM_NANO33BLE_INUSE)\n    MW_NANO33BLE_PWM_Setup();\n    #endif\n    #endif\n}\n\nvoid MW_Arduino_Init(void)\n{\n    //Hardware specific init for Arduino nano 33 ble sense\n    #if (defined(ARDUINO_ARDUINO_NANO33BLE))\n    MW_ArduinoNano33BLESenseInit();\n    #endif\n    //Disable watchdog for Arduino Due. watchdog\n    #if (defined(_ROTH_DUE_))\n    watchdogDisable();\n    #endif\n    //Disable watchdog for ESP32\n    #if (defined(ESP_PLATFORM))\n    initArduino();\n    disableCore0WDT();\n    #endif\n\n    /*\n    * Initialize Serial Peripheral\n    */\n    // Always Initialize Serial0\n    #if(defined(ESP_PLATFORM))\n    #else\n    Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n    #endif\n\n    /* Overrun Detection Initialization */\n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n    pinMode(_RTT_OVERRUN_DIGITAL_PIN_, OUTPUT);\n\n    /* Init the overrun detection pin to zero or else the Pin is always in a\n    * high/tristate giving the user a wrong indication of overrun conditions */\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, LOW);\n    #endif\n\n    /*\n    * Initialize Analog Reference Voltage\n    * Default - Due\n    * Default, Internal 1.1, Internal 2.56, External -  Mega 2560, Mega ADK\n    * Default, Internal, External - Other Arduino targets\n    */\n    #if (defined(_ROTH_MEGA2560_))\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL1V1);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(INTERNAL2V56);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(EXTERNAL);\n    #endif\n    #elif defined(ARDUINO_ARM_CORTEX_M0_PLUS)\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(AR_INTERNAL1V0);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(AR_INTERNAL1V65);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 3))\n    analogReference(AR_INTERNAL2V23);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 4))\n    analogReference(AR_EXTERNAL);\n    #endif\n    #else\n    #if (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 1))\n    analogReference(INTERNAL);\n    #elif (defined(_RTT_ANALOG_REF_) && (_RTT_ANALOG_REF_ == 2))\n    analogReference(EXTERNAL);\n    #endif\n    #endif\n\n    /*\n    * Initialize SPI bus\n    */\n    //_RTT_SPI_SSPIN_ definition is applicable for all boards excluding Due\n    #if (defined(_RTT_SPI_SSPIN_)) || (defined(MW_ARDUINO_OV2640CSPIN))\n    MW_SPIwriteReadSetup();\n    #endif\n\n    //Initialize Modbus\n    int modStatus;\n    #if defined(_RTT_MODBUS_MASTER_)\n    modStatus = ModbusRTUClient.begin(_RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    ModbusRTUClient.setTimeout(_RTT_MODBUS_MASTERTIMEOUT_/1000);\n    #endif\n\n    #if defined(_RTT_MODBUS_SLAVE_)\n    modStatus = ModbusRTUServer.begin(_RTT_MODBUS_SLAVEID_, _RTT_RS485_BAUD_, _RTT_RS485_CONFIG_);\n    #if defined(_RTT_MODBUS_CONFIGCOIL_)\n    ModbusRTUServer.configureCoils(_RTT_MODBUS_COILADDR_,_RTT_MODBUS_COILNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUT_)\n    ModbusRTUServer.configureDiscreteInputs(_RTT_MODBUS_INPUPTADDR_,_RTT_MODBUS_INPUTNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGHOLDINGREG_)\n    ModbusRTUServer.configureHoldingRegisters(_RTT_MODBUS_HOLDINGREGADDR_,_RTT_MODBUS_HOLDINGREGNUM_);\n    #endif\n    #if defined(_RTT_MODBUS_CONFIGINPUTREG_)\n    ModbusRTUServer.configureInputRegisters(_RTT_MODBUS_INPUTREGADDR_,_RTT_MODBUS_INPUTREGNUM_);\n    #endif\n    #endif\n\n    /*\n    * Initialize wifi\n    */\n    #if (defined(_RTT_WIFI_UDP_) && (_RTT_WIFI_UDP_ != 0)) || (defined(_RTT_WIFI_TCP_) && (_RTT_WIFI_TCP_ != 0))|| defined(_RTT_THINGSPEAK_WIFI_) || defined(_RTT_WEBSOCKET_PORT_) || defined(_RTT_MQTT_WIFI_) || defined(_RTT_HTTP_CLIENT_)\n    /* Begin WiFi*/\n    while(configureSuccess!=WL_CONNECTED)\n    {\n        #if (defined(_RTT_DISABLE_Wifi_DHCP_) && (_RTT_DISABLE_Wifi_DHCP_ !=0))\n            #ifdef ESP_PLATFORM\n                #if (_RTT_DISABLE_Wifi_DHCP_ == 1)\n                WiFi.config(wifiLocalIpAddress,wifigateway, subnet, dns1, dns2);\n                #else\n                WiFi.config(wifiLocalIpAddress, wifiGatewayAddress, wifiSubnetMask, wifiDNSAddress);\n                #endif\n            #elif (_RTT_DISABLE_Wifi_DHCP_ == 1)\n            WiFi.config(wifiLocalIpAddress);\n            #else\n            WiFi.config(wifiLocalIpAddress, wifiDNSAddress, wifiGatewayAddress, wifiSubnetMask);\n            #endif\n        #endif\n\n        #ifdef _RTT_WIFI_WEP\n        configureSuccess=WiFi.begin(ssid,keyIndex,key);\n        #endif //_RTT_WIFI_WEP\n\n        #ifdef _RTT_WIFI_WPA\n        configureSuccess=WiFi.begin(ssid,wpapass);\n        #endif //_RTT_WIFI_WPA\n\n        #ifdef _RTT_WIFI_WPA2_ENTERPRISE\n        #if defined(ESP_PLATFORM)\n        WiFi.disconnect(true);  //disconnect form wifi to set new wifi connection\n        WiFi.mode(WIFI_STA); //init wifi mode\n        configureSuccess = WiFi.begin(ssid, WPA2_AUTH_PEAP, wpa2username, wpa2username, wpa2password); //connect to wifi\n        #elif defined(ARDUINO_WIFI_LIB_NINA)\n        configureSuccess=WiFi.beginEnterprise(ssid,wpa2username,wpa2password);\n        #endif\n        #endif //_RTT_WIFI_WPA2_ENTERPRISE\n\n        #ifdef _RTT_WIFI_NONE\n        configureSuccess=WiFi.begin(ssid);\n        #endif //_RTT_WIFI_NONE\n\n        #if (defined(ESP_PLATFORM))\n        while (WiFi.status() != WL_CONNECTED) {\n            delay(500);\n        }\n        configureSuccess=WL_CONNECTED;\n        #else\n        //Wait for 10 seconds for Wifi connection to happen\n        unsigned long startMillis  = millis();\n        while(millis()- startMillis < 1000)\n        {\n        };\n        #endif\n    }\n\n    /* Wait for Serial0 to be up*/\n    for(trialcount=0;trialcount<5;trialcount++)\n    {\n        if(Serial)\n        {\n            break;\n        }else\n        {\n            unsigned long startMillis  = millis();\n            while(millis()- startMillis < 1000)\n            {\n            };\n        }\n    }\n\n    #if (!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n    if (configureSuccess==WL_CONNECTED)\n    {\n        // If the Configuration is successful, relay back the assigned IP address.\n        #if(defined(ESP_PLATFORM))\n        Serial_begin(0, _RTT_BAUDRATE_SERIAL0_, _RTT_CONFIG_SERIAL0_);\n        #endif\n        IPAddress ip = WiFi.localIP();\n        //Adding a precautionary check using a Serial command so as to print the IP address so that it is available at least 6 times \n        //and the chances of it not being assigned to Target are minimised.\n        for(int ipSendcounter=0; ipSendcounter<6; ipSendcounter++)\n        {\n            Serial.print(\"<<< IP address :\");\n            Serial.print(ip);\n            Serial.println(\" >>>\");\n            delay(500);\n        }\n    }\n    else\n    {\n        // If the Configuration failed,relay back the error message.\n        Serial.println(\"<<< IP address :Failed to configure. >>>\");\n    }\n    #endif //(!(defined(_RTT_WIFI_EXTMODE_) && (_RTT_WIFI_EXTMODE_ == 1)))\n\n    #endif /*Initialize wifi*/\n    #ifdef NANO_MOTOR_CARRIER\n    MW_EnableNanoCarrierBatteryCharging();\n    #endif\n    #ifdef _MW_DASHBOARD_BLOCK_PRESENT_\n    MW_initScreen();\n    #endif\n\n    #if defined(ARDUINO_ARCH_SAMD) && defined(MW_SAMD_EVSYS_ENABLE)\n    PM->APBCMASK.reg |= PM_APBCMASK_EVSYS;                                              // Switch on the event system peripheral\n    #if defined(MW_SAMD_EVSYS_CH0)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(1) |                                           // Attach the event user (receiver) to channel 0 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH0_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH1_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH0_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH1_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(0);                                      // Attach the generator (sender) to channel 0\n    EVSYS_CH0_USER->EVCTRL.reg |= EVSYS_CH0_USER_START_CMD;\n    EVSYS_CH0_GEN->EVCTRL.reg |= EVSYS_CH0_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH1)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(2) |                                           // Attach the event user (receiver) to channel 1 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH1_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH2_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH1_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH2_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(1);                                      // Attach the generator (sender) to channel 1\n    EVSYS_CH1_USER->EVCTRL.reg |= EVSYS_CH1_USER_START_CMD;\n    EVSYS_CH1_GEN->EVCTRL.reg |= EVSYS_CH1_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH2)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(3) |                                           // Attach the event user (receiver) to channel 2 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH2_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH3_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH2_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH3_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(2);                                      // Attach the generator (sender) to channel 2\n    EVSYS_CH2_USER->EVCTRL.reg |= EVSYS_CH2_USER_START_CMD;\n    EVSYS_CH2_GEN->EVCTRL.reg |= EVSYS_CH2_GEN_START_CMD;\n    #endif\n    #if defined(MW_SAMD_EVSYS_CH3)\n    EVSYS->USER.reg = EVSYS_USER_CHANNEL(4) |                                           // Attach the event user (receiver) to channel 3 (n + 1)\n        EVSYS_USER_USER(EVSYS_CH3_USER_EVENT);                            // Set the event user (receiver) as EVSYS_CH4_USER_EVENT\n    EVSYS->CHANNEL.reg = EVSYS_CHANNEL_EDGSEL_NO_EVT_OUTPUT |                           // No event edge detection\n        EVSYS_CHANNEL_PATH_ASYNCHRONOUS |                              // Set event path as asynchronous\n        EVSYS_CHANNEL_EVGEN(EVSYS_CH3_GEN_EVENT) |                     // Set event generator (sender) as EVSYS_CH4_GEN_EVENT\n        EVSYS_CHANNEL_CHANNEL(3);                                      // Attach the generator (sender) to channel 3\n    EVSYS_CH3_USER->EVCTRL.reg |= EVSYS_CH3_USER_START_CMD;\n    EVSYS_CH3_GEN->EVCTRL.reg |= EVSYS_CH3_GEN_START_CMD;\n    #endif\n    #endif\n}\n/* Function: MW_Arduino_Terminate ================================================\n* For Arduino MKR/Leonardo and its variants, the Virtual COM port is handled\n* by the controller. In case the code running on the target exits main,\n* the COM port cannot be accessed until a hard reset is performed.\n* To over come this issue, a while loop is added to make sure that\n* upon getting a stop command from external mode, the code running on\n* the target stops but the code will not exit the main.\n* This will ensure that the COM port is accessible even after the\n* external mode has been stopped. */\nvoid MW_Arduino_Terminate(void){\n    #if defined(ARDUINO_VIRTUAL_COM_PORT) || (defined(ARDUINO_ARDUINO_NANO33BLE) && (!defined(USE_MBEDRTOS)))\n    disable_rt_OneStep();\n    while(1){};     /* To continue virtual COM port functionality */\n    #endif\n}\n\n#ifdef NANO_MOTOR_CARRIER\nvoid MW_EnableNanoCarrierBatteryCharging(void) {\n    Wire.begin();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG00);\n    Wire.write(0x06); // min sys voltage 3.88V + max input current 2.0 A\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG01);\n    Wire.write(0x1B); // Charge Battery + Minimum System Voltage 3.5V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG02);\n    Wire.write(0x00); // Charge current  512 mA\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG04);\n    Wire.write(0x9E); // Charge Voltage Limit 4.128V\n    Wire.endTransmission();\n    Wire.beginTransmission(PMIC_ADDRESS);\n    Wire.write(PMIC_REG05);\n    Wire.write(0x8A); // Enable Battery Charge termination + disable watchdog\n    Wire.endTransmission();\n}\n#endif\n\n\n// Overrun detection function for ESP32\n#if defined(ESP_PLATFORM) && defined(_RTT_OVERRUN_DIGITAL_PIN_)\nvoid onOverrunDetect(int id)\n{\n    digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n}\n#endif\n// LocalWords:  AVR Bareboard ADK SPI RTT SSPIN Modbus MKR"},{"name":"MW_target_hardware_resources.h","type":"header","group":"other","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw","tag":"","groupDisplay":"Other files","code":"#ifndef PORTABLE_WORDSIZES\n#ifdef __MW_TARGET_USE_HARDWARE_RESOURCES_H__\n#ifndef __MW_TARGET_HARDWARE_RESOURCES_H__\n#define __MW_TARGET_HARDWARE_RESOURCES_H__\n\n#define MW_MULTI_TASKING_MODE 1\n#include \"arduinoAVRScheduler.h\"\n\n#define MW_USECODERTARGET 1\n#define MW_TARGETHARDWARE Arduino Uno\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERSIZE 250\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_LOGGINGBUFFERNUM 2\n#define MW_EXTMODEPROTOCOLINFO_XCPONSERIAL_MAXCONTIGSAMPLES 10\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERSIZE 250\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_LOGGINGBUFFERNUM 2\n#define MW_EXTMODEPROTOCOLINFO_XCPONTCPIP_MAXCONTIGSAMPLES 10\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_HOSTINTERFACE Simulink\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERAUTO 1\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERSIZE 250\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_LOGGINGBUFFERNUM 2\n#define MW_EXTMODEPROTOCOLINFO_XCPONWIFI_MAXCONTIGSAMPLES 10\n#define MW_CONNECTIONINFO_XCPONSERIAL_BAUDRATE codertarget.arduinobase.registry.getBaudRate\n#define MW_CONNECTIONINFO_XCPONSERIAL_COMPORT codertarget.arduinobase.internal.getExternalModeMexArgs('Serial')\n#define MW_CONNECTIONINFO_XCPONSERIAL_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONTCPIP_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Ethernet')\n#define MW_CONNECTIONINFO_XCPONTCPIP_PORT 17725\n#define MW_CONNECTIONINFO_XCPONTCPIP_VERBOSE 0\n#define MW_CONNECTIONINFO_XCPONWIFI_IPADDRESS codertarget.arduinobase.internal.getExternalModeMexArgs('Wifi')\n#define MW_CONNECTIONINFO_XCPONWIFI_PORT 17725\n#define MW_CONNECTIONINFO_XCPONWIFI_VERBOSE 0\n#define MW_EXTMODE_CONFIGURATION XCP on Serial\n#define MW_EXTMODE_COMPORTBAUD 115200\n#define MW_EXTMODE_USEREALTIMESTAMPLOGGING 0\n#define MW_RTOS Baremetal\n#define MW_SCHEDULER_INTERRUPT_SOURCE 0\n#define MW_RUNTIME_BUILDACTION 1\n#define MW_RUNTIME_DISABLEPARALLELBUILD 0\n#define MW_RUNTIME_FORCEBUILDSTATICLIBRARY 0\n#define MW_RUNTIME_VERBOSEOUTPUT 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_PORT_SOURCE 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_COMPORT_SPECIFY /dev/ttyACM0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD 0\n#define MW_HOSTBOARDCONNECTION_APPDOWNLOAD_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE1 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_COMPORT_SPECIFY /dev/ttyACM0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD 0\n#define MW_HOSTBOARDCONNECTION_CONNECTEDIO_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE1 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_COMPORT_SPECIFY /dev/ttyACM0\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD -1\n#define MW_HOSTBOARDCONNECTION_EXTERNALMODE_BAUD_SPECIFY \n#define MW_HOSTBOARDCONNECTION_PIL_SERIAL_PORT 0\n#define MW_HOSTBOARDCONNECTION_PIL_PORT_SOURCE1 0\n#define MW_HOSTBOARDCONNECTION_PIL_PORT_SOURCE2 0\n#define MW_HOSTBOARDCONNECTION_PIL_COMPORT_SELECT -1\n#define MW_HOSTBOARDCONNECTION_PIL_COMPORT_SPECIFY /dev/ttyACM0\n#define MW_HOSTBOARDCONNECTION_PIL_BAUD 0\n#define MW_HOSTBOARDCONNECTION_PIL_BAUD_SPECIFY \n#define MW_CONNECTEDIO_CONNECTEDIOMODE 0\n#define MW_CONNECTEDIO_ACTIONONOVERRUN 0\n#define MW_OVERRUNDETECTION_ENABLE_OVERRUN_DETECTION 0\n#define MW_OVERRUNDETECTION_DIGITAL_OUTPUT_TO_SET_ON_OVERRUN 13\n#define MW_ANALOGINREFVOLTAGE_ANALOG_INPUT_REFERENCE_VOLTAGE 0.000000\n#define MW_SERIAL_SERIAL0_BAUD_RATE 8\n#define MW_SERIAL_SERIAL0_BAUD_SPECIFY 921600\n#define MW_SERIAL_SERIAL0_CONFIG 3\n#define MW_I2C_I2C0BUSSPEEDHZ 100000\n#define MW_SPI_SPI0_CLOCK_OUT_FREQUENCY 1\n#define MW_SPI_SPI0_MODE 0\n#define MW_SPI_SPI0_BITORDER 0\n#define MW_SPI_SDSLAVESELECT 4.000000\n#define MW_SPI_CANCHIPSELECT 9.000000\n#define MW_ETHERNET_DISABLE_DHCP_ETHERNET 0\n#define MW_ETHERNET_LOCAL_IP_ADDRESS 192.168.0.20\n#define MW_ETHERNET_LOCAL_MAC_ADDRESS DE:AD:BE:EF:FE:ED\n#define MW_WIFI_WIFI_HARDWARE 0\n#define MW_WIFI_WIFI_SSID yourNetwork\n#define MW_WIFI_SET_WIFI_ENCRYPTION 0\n#define MW_WIFI_WIFI_WEP_KEY D0D0DEADF00DABBADEAFBEADED\n#define MW_WIFI_WIFI_WEP_KEY_INDEX 0\n#define MW_WIFI_WIFI_WPA_PASSWORD secretPassword\n#define MW_WIFI_WIFI_ESP8266_HW_SERIAL_PORT 0\n#define MW_WIFI_IP_ADDRESS_ASSIGNMENT 0\n#define MW_WIFI_WIFI_IP_ADDRESS 192.168.1.20\n#define MW_THINGSPEAK_ENABLE_CUSTOMSERVER 48\n#define MW_THINGSPEAK_IP_ADDRESS 184.106.153.149\n#define MW_THINGSPEAK_PORT 80\n#define MW_CAN_CANBUSSPEED 10\n#define MW_CAN_CANOSCILLATORFREQUENCY 1\n#define MW_CAN_INTERRUPTPIN 2.000000\n#define MW_CAN_ALLOWALLFILTER 0\n#define MW_CAN_BUFFER0IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK0_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER0_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER1_NOR 255\n#define MW_CAN_ACCEPTANCEMASK0_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER0_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER1_EXT 255\n#define MW_CAN_BUFFER1IDTYPE 0\n#define MW_CAN_ACCEPTANCEMASK1_NOR 0\n#define MW_CAN_ACCEPTANCEFILTER2_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER3_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER4_NOR 255\n#define MW_CAN_ACCEPTANCEFILTER5_NOR 255\n#define MW_CAN_ACCEPTANCEMASK1_EXT 0\n#define MW_CAN_ACCEPTANCEFILTER2_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER3_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER4_EXT 255\n#define MW_CAN_ACCEPTANCEFILTER5_EXT 255\n#define MW_MODBUS_MODBUS_COMMS 0\n#define MW_MODBUS_MODBUS_MODE 0\n#define MW_MODBUS_MODBUS_SLAVEID 1\n#define MW_MODBUS_MODBUS_CONFIGCOIL 49\n#define MW_MODBUS_MODBUS_COILADDR 0\n#define MW_MODBUS_MODBUS_COILNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUT 49\n#define MW_MODBUS_MODBUS_INPUTADDR 0\n#define MW_MODBUS_MODBUS_INPUTNUM 1\n#define MW_MODBUS_MODBUS_CONFIGHOLDINGREG 49\n#define MW_MODBUS_MODBUS_HOLDINGREGADDR 0\n#define MW_MODBUS_MODBUS_HOLDINGREGNUM 1\n#define MW_MODBUS_MODBUS_CONFIGINPUTREG 49\n#define MW_MODBUS_MODBUS_INPUTREGADDR 0\n#define MW_MODBUS_MODBUS_INPUTREGNUM 1\n#define MW_MODBUS_MODBUS_MASTERTIMEOUT 100\n#define MW_RS485_RS485_SERIAL 0\n#define MW_RS485_RS485_BAUD 9600\n#define MW_RS485_RS485_CONFIG 3\n#define MW_RS485_RS485_DEPIN 8\n#define MW_RS485_RS485_REPIN 9\n#define MW_DISPLAY_ENABLECODEGEN 0\n#define MW_DISPLAY_APPLAUNCHBUTTON \n#define MW_IOBLOCKSMODE deployed\n#define MW_DATAVERSION 2016.02\n#define MW_DASHBOARDCODEGENINFO_ENABLECODEGEN 0\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.circularGauge\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_CIRCULARGAUGE_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.lcdTextDisplay\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_DISPLAYBLOCK_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_CODEGEN 1\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_BLOCKCLASS codertarget.targetHiddenBlkInsert.internal.pushButton\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_REGFCN codertarget.arduinobase.blocks.registerDashboardBlk\n#define MW_DASHBOARDCODEGENINFO_PUSHBUTTON_VALIDATEFCN codertarget.targetHiddenBlkInsert.internal.isDashboardBlockCodegenEnabled\n\n#endif /* __MW_TARGET_HARDWARE_RESOURCES_H__ */\n\n#endif\n\n#endif\n"},{"name":"arduinoAVRScheduler.cpp","type":"source","group":"legacy","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw/../../../../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/arduinotarget/scheduler/src","tag":"","groupDisplay":"Other files","code":"/* Arduino AVR Bareboard scheduler\n *\n * Copyright 2013-2015 The MathWorks, Inc.\n */\n\n#include \"Arduino.h\"\n#include \"arduinoAVRScheduler.h\"\n\nextern volatile int IsrOverrun;\nunsigned long oldtime = 0L;\nunsigned long actualtime;\n\n\n#if (defined(MW_SCHEDULERCOUNTER) &&  (MW_SCHEDULERCOUNTER > 1))\n   #if (MW_SCHEDULERCOUNTER >= 65536)\n      volatile uint32_t scheduler_counter = 0;\n    #elif (MW_SCHEDULERCOUNTER >= 256)\n      volatile uint16_t scheduler_counter = 0;\n    #else\n      volatile uint8_t scheduler_counter = 0;\n    #endif\n#endif\n                                  \n/*\n * Call the rt_Onestep function when the timer interrupt hits\n *\n */\n#ifndef _MW_ARDUINO_LOOP_\nISR(INTERRUPT_VECTOR)\n{\n    RESET_TIMER;\n    \n    #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      if ((++scheduler_counter) == MW_SCHEDULERCOUNTER) {\n         scheduler_counter = 0;\n    #endif\n\n    #ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n          // Overrun detected\n          digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n    #endif\n      rt_OneStep();\n         \n    #if (defined(MW_SCHEDULERCOUNTER) && (MW_SCHEDULERCOUNTER > 1))\n      }\n    #endif\n}\n#endif    \n\nvoid configureArduinoAVRTimer(void)\n{\n#ifndef _MW_ARDUINO_LOOP_\n  // Sets up the timer overflow interrupt.\n  RESET_TIMER;\n\n  // Initially disable the overflow interrupt (before configuration).\n  DISABLE_SCHEDULER_INT();\n\n  // Set the timer to normal mode.\n  TIMER_NORMAL_MODE;\n\n  // Set the prescaler.\n  SETUP_PRESCALER;\n\n  // Enable the overflow interrupt.\n  ENABLE_SCHEDULER_INT();    \n#endif  \n}\n\nboolean disable_rt_OneStep(void)\n{\n    boolean t_return = 0U;\n#ifndef _MW_ARDUINO_LOOP_\n    t_return = GET_SCHEDULER_INT_EN_STATUS();\n  // Disable the overflow interrupt for XCP External Mode\n  DISABLE_SCHEDULER_INT();  \n#endif \n  return t_return;\n}\n\nvoid enable_rt_OneStep(void)\n{\n#ifndef _MW_ARDUINO_LOOP_\n  // Enable the overflow interrupt\n  ENABLE_SCHEDULER_INT();  \n#endif \n}\n\nboolean MW_Arduino_Loop(void)\n{\n    boolean ret = 0;\n\n#ifdef _MW_ARDUINO_LOOP_\n    unsigned long overruntime;\n#if (defined(MW_ARDUINO_MICROS))\n    actualtime = micros();\n#else\n    actualtime = millis();\n#endif\n  \n    if ((unsigned long) (actualtime - oldtime) >= MW_ARDUINO_STEP_SIZE)\n    {\n        oldtime = actualtime;\n        \n#ifdef _RTT_OVERRUN_DIGITAL_PIN_\n        if (IsrOverrun == 1)\n        {\n            // Overrun detected\n            digitalWrite(_RTT_OVERRUN_DIGITAL_PIN_, HIGH);\n        }\n#endif\n        rt_OneStep();\n            #if (defined(_MW_ARDUINO_LOOP_))\n                #if (defined(MW_ARDUINO_MICROS))\n                        overruntime = micros();\n                #else\n                        overruntime = millis();\n                #endif\n                if ((unsigned long) (overruntime - oldtime) >= MW_ARDUINO_STEP_SIZE)   \n                  IsrOverrun = 1;\n                else\n                  IsrOverrun = 0;\n            #endif\n}\n#endif\n\n    ret = 1;\n    return ret;\n}\n\n"},{"name":"io_wrappers.cpp","type":"source","group":"legacy","path":"/home/amir/Desktop/Simulink/ex4/q4/q4b/q4b_ert_rtw/../../../../../../Documents/MATLAB/SupportPackages/R2024a/toolbox/target/supportpackages/arduinobase/src","tag":"","groupDisplay":"Other files","code":"/*\n* Wrappers to make I/O functions available with C linkage. This allows C++\n* methods to be called from C code.\n*\n* Copyright 2011-2022 The MathWorks, Inc. */\n\n#include <inttypes.h>\n#include \"Arduino.h\"\n#include \"rtwtypes.h\"\n\n#if (defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)) || (defined(_RTT_UDP_) && (_RTT_UDP_ != 0)) || (defined(_RTT_TCP_) && (_RTT_TCP_ != 0) || defined(_RTT_THINGSPEAK_))\n#include <Ethernet.h>\n#include <EthernetUdp.h>\n#include <SPI.h>\n#endif\n\n#if defined(ARDUINO_ARM_CORTEX_M0_PLUS)\nextern \"C\" void __libc_init_array(void);\n#endif\n\nextern \"C\" {\n    void __cxa_pure_virtual(void);\n}\n\nextern \"C\" void Serial_begin(int port, long r, int c)\n{\n    static int serialInit=0;\n    #if !(defined(ESP_PLATFORM))\n    serialInit=0;   //Reset serialInit flag for all targets except ESP32\n    #endif\n    #if defined(ARDUINO_ARCH_SAM)\n    UARTClass::UARTModes config = UARTClass::UARTModes(c);\n    #else\n    int config = c;\n    #endif\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            if(serialInit & 1)return;\n            serialInit |= 1;\n            #if defined(ESP_PLATFORM)\n            Serial.begin(r,config,_RTT_RX_PIN_SERIAL0_,_RTT_TX_PIN_SERIAL0_);\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial.begin(r);\n            #else\n            Serial.begin(r,config);\n            #endif\n            break;\n        case 1:\n            if(serialInit & 2)return;\n            serialInit |= 2;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            #if defined(ESP_PLATFORM)\n            Serial1.begin(r,config,_RTT_RX_PIN_SERIAL1_,_RTT_TX_PIN_SERIAL1_);\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial1.begin(r);\n            #else\n            Serial1.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 2:\n            if(serialInit & 4)return;\n            serialInit |= 4;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            #if defined(ESP_PLATFORM)\n            Serial2.begin(r,config,_RTT_RX_PIN_SERIAL2_,_RTT_TX_PIN_SERIAL2_);\n            #elif (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial2.begin(r);\n            #else\n            Serial2.begin(r,config);\n            #endif\n            #endif\n            break;\n        case 3:\n            if(serialInit & 8)return;\n            serialInit |= 8;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial3.begin(r);\n            #else\n            Serial3.begin(r,config);\n            #endif\n            #endif\n\n            break;\n        case 4:\n            if(serialInit & 16)return;\n            serialInit |= 16;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial4.begin(r);\n            #else\n            Serial4.begin(r,config);\n            #endif\n            #endif\n            break;\n       case 5:\n            if(serialInit & 32)return;\n            serialInit |= 32;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial5.begin(r);\n            #else\n            Serial5.begin(r,config);\n            #endif\n            #endif\n\n            break;\n       case 6:\n            if(serialInit & 64)return;\n            serialInit |= 64;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial6.begin(r);\n            #else\n            Serial6.begin(r,config);\n            #endif\n            #endif\n\n            break;\n        case 7:\n            if(serialInit & 128)return;\n            serialInit |= 128;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            #if (defined(ARDUINO_TEENSY40) ||defined(ARDUINO_TEENSY41))\n            Serial7.begin(r);\n            #else\n            Serial7.begin(r,config);\n            #endif\n            #endif\n      case 8:\n            if(serialInit & 256)return;\n            serialInit |= 256;\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            #if (defined(ARDUINO_TEENSY41))\n            Serial8.begin(r);\n            #else\n            Serial8.begin(r,config);\n            #endif\n            #endif\n\n            break;\n\n            break;\n    }\n    #else\n    if(serialInit & 1)return;\n    serialInit |= 1;\n    Serial.begin(r,SERIAL_8N1);\n    #endif\n}\n\nextern \"C\" void Serial_read(int port, int showOutStatus, uint8_t *outData, int16_t *outStatus)\n{\n    int libFcnOutput;\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            libFcnOutput = Serial.read();\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            libFcnOutput = Serial1.read();\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            libFcnOutput = Serial2.read();\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            libFcnOutput = Serial3.read();\n            #endif\n            break;\n        case 4:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            libFcnOutput = Serial4.read();\n            #endif\n            break;\n        case 5:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            libFcnOutput = Serial5.read();\n            #endif\n            break;\n        case 6:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            libFcnOutput = Serial6.read();\n            #endif\n            break;\n       case 7:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            libFcnOutput = Serial7.read();\n            #endif\n            break;\n       case 8:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            libFcnOutput = Serial8.read();\n            #endif\n            break;\n    }\n    #else\n    libFcnOutput = Serial.read();\n    #endif\n    *outData = (uint8_t) libFcnOutput;\n    *outStatus = (libFcnOutput != -1);\n}\n\nextern \"C\" void Serial_write(int port, uint8_t * c, size_t s)\n{\n    #if defined(ARDUINO_NUM_SERIAL_PORTS)\n    switch(port) {\n        case 0:\n            Serial.write(c, s);\n            break;\n        case 1:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 2)\n            Serial1.write(c, s);\n            #endif\n            break;\n        case 2:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 3)\n            Serial2.write(c, s);\n            #endif\n            break;\n        case 3:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 4)\n            Serial3.write(c, s);\n            #endif\n            break;\n        case 4:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 5)\n            Serial4.write(c, s);\n            #endif\n            break;\n        case 5:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 6)\n            Serial5.write(c, s);\n            #endif\n            break;\n        case 6:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 7)\n            Serial6.write(c, s);\n            #endif\n            break;\n        case 7:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 8)\n            Serial7.write(c, s);\n            #endif\n            break;\n        case 8:\n            #if(ARDUINO_NUM_SERIAL_PORTS >= 9)\n            Serial8.write(c, s);\n            #endif\n            break;\n    }\n    #else\n    Serial.write(c, s);\n    #endif\n}\n\n#if _RTT_UDP_ != 0\nEthernetUDP Udp[_RTT_UDP_];\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nunsigned int localport[_RTT_UDP_] = {_RTT_UDP_LOCAL_PORT_ORDERED};\nint configureSuccess;\nint trialcount=0;\nextern \"C\" uint8_t MW_EthernetAndUDPBegin(uint8_t udpindex, uint32_t localPort)\n{\n    static int only_one_ethernet_begin;\n    if (only_one_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n    }\n    return (Udp[udpindex].begin(localport[udpindex]));\n}\n\nextern \"C\" int MW_UDPFinalWrite(uint8_t udpindex, uint8_t data, uint8_t remoteIPOctect1,uint8_t remoteIPOctect2,uint8_t remoteIPOctect3,uint8_t remoteIPOctect4, uint32_t remoteport)\n{\n    IPAddress remoteIpAddress(remoteIPOctect1,remoteIPOctect2, remoteIPOctect3, remoteIPOctect4);\n    Udp[udpindex].beginPacket(remoteIpAddress, remoteport);\n    Udp[udpindex].write(data);\n    return(Udp[udpindex].endPacket());\n}\n\nextern \"C\" void MW_UDPFinalRead(uint8_t udpindex, uint8_t *data, int32_t *outStatus)\n{\n    int packetSize = Udp[udpindex].parsePacket();\n    if(packetSize)\n    {\n        int libFcnOutput;\n        libFcnOutput = Udp[udpindex].read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n    }\n\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n}\n#endif\n\n#if defined(_RTT_THINGSPEAK_) || (_RTT_TCP_ != 0)\nIPAddress localIpAddress(_RTT_Local_IP1, _RTT_Local_IP2, _RTT_Local_IP3, _RTT_Local_IP4);\nbyte mac[] = { _RTT_Local_MAC1, _RTT_Local_MAC2, _RTT_Local_MAC3, _RTT_Local_MAC4, _RTT_Local_MAC5, _RTT_Local_MAC6 };\nint configureSuccess;\nint trialcount;\n#if _RTT_TCP_ != 0\nEthernetServer server[_RTT_TCP_] = {_RTT_TCP_SERVER_PORT_ORDERED};\n#endif\nextern \"C\" void MW_EthernetAndTCPServerBegin(uint8_t tcpindex, uint32_t serverport)\n{\n    static int only_one_tcp_server_and_ethernet_begin = 0;\n\n    if (only_one_tcp_server_and_ethernet_begin==0)\n    {\n        #if (defined(_RTT_DISABLE_Ethernet_DHCP_) && (_RTT_DISABLE_Ethernet_DHCP_ !=0))\n        Ethernet.begin(mac, localIpAddress);\n        configureSuccess = 1;\n        #else\n        configureSuccess = Ethernet.begin(mac);\n        #endif\n        only_one_tcp_server_and_ethernet_begin++;\n\n        for(trialcount=0;trialcount<5;trialcount++)\n        {\n            if(Serial)\n            {\n                break;\n            }else\n            {\n                delay(1000);\n            }\n        }\n\n        // Depending on if the IP address assignment using DHCP has been successful or not,\n        // send the appropriate information back to the host.\n        // If External mode over TCP/IP or Wifi, do not print this Info. Information of IP address will be printed as\n        // a part of rtiostream_open\n        #if (!(defined(_RTT_TCPIP_EXTMODE_) && (_RTT_TCPIP_EXTMODE_ == 1)))\n        if (configureSuccess==1)\n        {\n            if(Ethernet.localIP()[0] == 0 || Ethernet.localIP()[0] == 255)\n            {\n                /*Tried to assign Static IP, failed due to one of the following reasons :\n                * 1. Ethernet shield is not connected properly with Arduino.\n                * 2. Ethernet shield is not connected to a network.\n                **/\n                Serial.println(\"<<<IP address: Failed to configure.>>>\");\n            }\n            else\n            {\n                // If the Configuration is successful, relay back the assigned IP address.\n                Serial.print(\"<<<IP address: \");\n                for (byte thisByte = 0; thisByte < 4; thisByte++)\n                {\n                    // Print the value of each byte of the IP address:\n                    Serial.print(Ethernet.localIP()[thisByte], DEC);\n                    if (thisByte<3)\n                    {\n                        Serial.print(\".\");\n                    }\n                }\n                Serial.println(\">>>\");\n            }\n        }\n        else\n        {\n            // If the Configuration failed,relay back the error message.\n            Serial.println(\"<<<IP address: Failed to configure.>>>\");\n        }\n        Serial.flush();\n        #endif\n\n        #if _RTT_TCP_ != 0\n        // Begin all servers based on the number of different TCP ports.\n        for (int i = 0;i < _RTT_TCP_;i++)\n        {\n            server[i].begin();\n        }\n        #endif\n        only_one_tcp_server_and_ethernet_begin = 1;\n    }\n}\n#endif\n#if _RTT_TCP_ != 0\nextern \"C\" void MW_TCPFinalread(uint8_t tcpindex, uint8_t *data, uint32_t serverport, int32_t *outStatus)\n{\n    int libFcnOutput;\n    EthernetClient client = server[tcpindex].available();\n    if (int(client) == true) {\n        libFcnOutput = client.read();\n        *data = (uint8_t) libFcnOutput;\n        *outStatus = (libFcnOutput != -1);\n\n    }\n    else\n    {\n        //When the client is not connected the status flag is accordingly toggled.\n        *outStatus = 0;\n    }\n\n}\nextern \"C\" void MW_TCPFinalWrite(uint8_t tcpindex, uint8_t data, uint32_t serverport)\n{\n    server[tcpindex].write(data);\n}\n#endif\n\n\n#if defined(_ROTH_LEONARDO_)\nextern \"C\" void MW_usbattach()\n{\n    USBDevice.attach();\n}\n#elif defined(ARDUINO_VIRTUAL_COM_PORT)\nextern \"C\" void MW_usbattach()\n{\n    __libc_init_array();\n    USBDevice.init();\n    USBDevice.attach();\n\n}\n#endif\n\nextern \"C\" void MW_pinModeAnalogInput(uint32_t pinNumber)\n{\n    if (pinNumber < A0)\n        pinNumber += A0;\n    pinMode(pinNumber, INPUT);\n}\n\nextern \"C\" void MW_delay_in_milliseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = millis();\n    while(millis()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" void MW_delay_in_microseconds(uint32_T period)\n{\n    uint32_T start_time = 0;\n    start_time = micros();\n    while(micros()- start_time <= period)\n    {\n        1;\n    }\n}\n\nextern \"C\" uint32_T MW_getCurrentTime_in_milliseconds()\n{\n   return (uint32_T)millis();\n}\n\n\n// #if defined(ARDUINO_ARDUINO_NANO33BLE)\n// #include \"Arduino.h\"\n// #include \"pins_arduino.h\"\n// #include \"mbed/drivers/AnalogIn.h\"\n// #include \"mbed.h\"\n//\n// extern uint8_t nano33BLE_dutycycle[21];\n// extern uint16_t nano33BLE_period[21];\n//\n//\n// events::EventQueue queue(32 * EVENTS_EVENT_SIZE);\n// rtos::Thread t;\n// mbed::Ticker tick;\n//\n// static int write_resolution = 8;\n// static int read_resolution = 10;\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite_1(pin_size_t pin, int val, uint16_t period)\n// {\n//   if (pin >= PINS_COUNT) {\n//     return;\n//   }\n//   float percent = (float)val/(float)((1 << write_resolution)-1);\n//   mbed::PwmOut* pwm = digitalPinToPwm(pin);\n//   if (pwm == NULL) {\n//     pwm = new mbed::PwmOut(digitalPinToPinName(pin));\n//     digitalPinToPwm(pin) = pwm;\n//     pwm->period_ms(period);\n//   }\n//   pwm->write(percent);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Handler()\n// {\n//     MW_NANO33BLE_analogWrite_1(5, nano33BLE_dutycycle[5], nano33BLE_period[5]);\n// }\n//\n// extern \"C\" void MW_NANO33BLE_PWM_Setup()\n// {\n//   t.start(callback(&queue, &events::EventQueue::dispatch_forever));\n//   tick.attach(queue.event(MW_NANO33BLE_PWM_Handler),_RTT_PWM_PIN5_CST );\n// }\n//\n//\n//\n//\n// extern \"C\" void MW_NANO33BLE_analogWrite(PinName pin, int val, uint16_t period)\n// {\n// //   pin_size_t idx = PinNameToIndex(pin);\n// //   if (idx != NOT_A_PIN) {\n// //     MW_NANO33BLE_analogWrite_1(idx, 50, period);\n// //   } else {\n// //     mbed::PwmOut* pwm = new mbed::PwmOut(pin);\n// //     pwm->period_ms(2);\n// //     float percent = (float)50/(float)((1 << write_resolution)-1);\n// //     pwm->write(percent);\n// //   }\n// }\n//\n// #endif\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};